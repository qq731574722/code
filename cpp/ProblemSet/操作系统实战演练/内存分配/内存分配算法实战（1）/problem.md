# 内存分配算法实战（1）

## 题目描述

首次适应算法，简单说就是找第一个满足大小的分区。

该算法从空闲分区链首开始查找，直至找到第一个能满足其大小要求的空闲分区为止。然后再按照作业的大小，从该分区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲分区链中。

- **优点**：该算法倾向于使用内存中低地址部分的空闲区，在高地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的大空闲区。显然为以后到达的大作业分配大的内存空间创造了条件
- **缺点**：低地址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又从低地址部分开始，会增加查找的开销

我们可以将空闲分区抽象成这样(当然你也可以不这样写):

```c
struct mem_info
{
    unsigned start;         //起始地址
    unsigned size;          //大小
    struct mem_info* next;
};

```
为了保证内存对齐，我们约定所有的分区大小都是 4 的整数倍

操作系统中把这样的结构放在空闲分区链表维护，你作为未来的操作系统设计者，实现内存的首次适应算法只是第一步。  

## 输入

单组输入数据。
开始时，操作系统拥有 N 个大小为 Y 的空闲分区。
每个空闲分区的起始地址为$a_i$(16进制)
接下来，你需要接受 M 次分配内存的请求，每次请求的内存大小为 $b_i$。

- $1 \leq N,M \leq 10^3$
- $1 \leq b_i \leq Y \leq 10^6$ 
- Y可以被4整除

输入的第一行是 N Y M
接下来N行是 $a_i$
接下来M行是 $b_i$

## 输出

每次请求$a_i$大小的内存后，你应该给出请求的结果，如果请求成功，请输出其起始地址(占6位)，否则请输出"not enough memory!"

## 样例输入

```
4 8 6
00ff08
00ff10
00ff18
00ff20
1
8
7
5
5
3
```
## 样例输出

```
00ff08
00ff10
00ff18
00ff20
not enough memory!
00ff0c
```